import { FunctionParameters, ConvertGoTypeToSQLType } from "@/lib/common";

type ParsedColumnToken = {
  name: string;
  type: string;
};

export const fromGoDBStructToCreateSQLStmt = (
  data: string,
  conversionParameters: FunctionParameters
) => {
  // assumes go fmt has been run since go splits it by newline, so no delimiter except newline
  if (
    conversionParameters.tag === undefined ||
    conversionParameters.tag.length == 0
  ) {
    throw Error("Tag cannot be empty.");
  }
  validateGoStruct(data);
  const tag = "db";
  const columnTokens: ParsedColumnToken[] = [];
  const parseErrors: string[] = [];
  data
    .substring(data.indexOf("{") + 1, data.lastIndexOf("}"))
    .trim()
    .split("\n")
    .forEach((line, lineNumber) => {
      line = line.trim();
      if (line.length == 0) {
        return;
      }

      line = line.replaceAll(/\s{2,}/gm, " ");
      const tokens = line.split(" ");
      if (tokens.length < 3) {
        parseErrors.push(
          `Not enough tokens found on line: ${lineNumber} [${line}], expected 3, found ${tokens.length}, skipping...`
        );
        return;
      }
      const type = tokens[1];
      console.log(tokens[2]);
      const tagValue = tokens[2]
        ? tokens[2]
            .substring(
              tokens[2].indexOf(tag) + tag.length,
              tokens[2].indexOf('"', tokens[2].indexOf('"') + 1)
            )
            .replaceAll(/[:"]/gm, "")
            .trim()
        : "";
      const subTagForColName = conversionParameters.subTag;
      let colName = tokens[0];

      if (subTagForColName && subTagForColName.length > 0) {
        const colNameSplit = tagValue.split("=");
        if (colNameSplit.length < 2) {
          parseErrors.push(
            `Wrong format on line:${lineNumber} for subtag ${subTagForColName} in ${tagValue}, skipping...`
          );
          return;
        }
        if (tagValue.indexOf(subTagForColName) == -1) {
          parseErrors.push(
            `Subtag ${subTagForColName} not found on line: ${lineNumber} in [${line}]`
          );
          return;
        }
        colName = colNameSplit[1].split(" ")[0].trim();
      }
      let sqlType: string = "";
      try {
        sqlType = ConvertGoTypeToSQLType(type);
      } catch (e) {
        if (e instanceof Error) {
          parseErrors.push(
            `Could not convert to SQL type on line: ${lineNumber}, error: ${e.message}`
          );
          return;
        }
      }
      columnTokens.push({
        name: colName,
        type: sqlType,
      });
    });
  if (parseErrors.length > 0) {
    throw Error(parseErrors.join("\n"));
  }

  return `CREATE TABLE Autogenerated (\n${columnTokens
    .map((column) => "\t" + column.name + " " + column.type)
    .join(",\n")}\n)`;
};

export const validateGoStruct = (data: string) => {
  //non recursive regex, SQL cannot handle nested structs
  if (data.length == 0) {
    throw Error("Struct cannot be empty.");
  }
  const regex =
    /(type)\s+[\w\d]+\s+(struct)\s+\{\s+([\w\d]+\s+(\*|\[\])?(int|int8|int16|int32|int64|uint|uint8|uint16|uint32|uint64|string|float32|float64|bool|byte|interface\{\}|any|time\.Time)\s*(`[\w\d]+:"[\w\d\s=,]+"`)?\s*(\/\/.*)?\s+)*\}/gm;
  if (!regex.test(data)) {
    throw Error("Invalid Go Struct");
  }
};
